# TODO: use ID type for id? but it is serialized as string
type Raportti {
  id: Int!
  file_name: String
  key: String
  file_type: String
  source_system: String
  zip_name: String
  campaign: String
  track_number: String
  track_part: String
  track_id: String
  km_start: Int
  km_end: Int
  system: String
  nonparsed_inspection_datetime: String
  report_category: String
  size: Float
  parser_version: String
  zip_reception__year: String
  zip_reception__date: String
  year: Int
  extra_information: String
  maintenance_area: String
  is_empty: Boolean
  length: Int
  tilirataosanumero: String
  report_type: String
  temperature: Float
  measurement_start_location: String
  measurement_end_location: String
  measurement_direction: String
  maintenance_level: String
  status: String # TODO: needed?
  inspection_date: String # TODO date?
  parsed_at_datetime: String # TODO date?
  inspection_datetime: String # TODO date?
  metadata_changed_at_datetime: String # TODO date
}

type SearchRaporttiResponse {
  raportti: [Raportti!]
  count: Int!
  page: Int!
  page_size: Int!
}

input DateTimeIntervalInput {
  start: String
  end: String
}

type FieldAggregation {
  value: String!
  count: Int!
}

type MetaResponse {
  report_type: [FieldAggregation!]!
  file_type: [FieldAggregation!]!
  system: [FieldAggregation!]!
  track_part: [FieldAggregation!]!
  tilirataosanumero: [FieldAggregation!]!
  latest_inspection: String!
}

# TODO: stronger validation for inputs: datetime strings, enums
type Query {
  search_raportti(
    file_name: String
    key: String
    inspection_datetime: DateTimeIntervalInput
    system: [String!]
    report_type: [String!]
    track_part: [String!]
    tilirataosanumero: [String!]
    file_type: [String!]
    page: Int!
    page_size: Int!
    order_by_variable: String
  ): SearchRaporttiResponse!

  meta: MetaResponse!
}
